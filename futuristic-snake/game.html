<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Futuristic Snake Game</title>
    <!-- Load Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load the Inter font for a modern look -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap">
    <style>
        /* Custom styles for the game board and glow effects */
        body {
            background-color: #0d1117;
            color: #ffffff;
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 1rem;
            background-image: url('https://i.redd.it/0l8pcbaab7n51.jpg');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            background-attachment: fixed;
        }
        .container-glow {
            box-shadow: 0 0 10px #0ff, 0 0 20px #0ff, inset 0 0 10px #0ff;
        }
        .text-glow {
            text-shadow: 0 0 5px #0ff, 0 0 10px #0ff;
        }
        canvas {
            background-color: #000000;
            border: 2px solid #0ff;
            box-shadow: 0 0 10px #0ff, 0 0 20px #0ff, inset 0 0 10px #0ff;
            border-radius: 0.5rem;
        }
        .btn-glow {
            box-shadow: 0 0 5px #ff007b, 0 0 10px #ff007b, 0 0 20px #ff007b;
            transition: transform 0.2s ease-in-out;
        }
        .btn-glow:hover {
            box-shadow: 0 0 10px #ff007b, 0 0 20px #ff007b, 0 0 40px #ff007b;
            transform: translateY(-2px);
        }
        /* Style for the screen shake effect */
        .shake {
            animation: shake 0.3s cubic-bezier(.36,.07,.19,.97) both;
            transform: translate3d(0, 0, 0);
            backface-visibility: hidden;
            perspective: 1000px;
        }
        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }

        /* Style for the game over modal */
        #gameOverModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
            z-index: 10;
        }
        #gameOverContent {
            background-color: #1a202c;
            border: 2px solid #ff007b;
            border-radius: 1rem;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 0 10px #ff007b, 0 0 20px #ff007b;
        }
        #gameOverText {
            font-size: 2rem;
            font-weight: bold;
            text-transform: uppercase;
            margin-bottom: 1rem;
            color: #ff007b;
            text-shadow: 0 0 5px #ff007b, 0 0 10px #ff007b;
        }
        #finalScoreText {
            font-size: 1.5rem;
            margin-bottom: 2rem;
            color: #ffffff;
        }
    </style>
</head>
<body class="bg-slate-900 text-white font-['Inter']">

    <div class="flex flex-col items-center justify-center p-4">
        <!-- Game Title -->
        <h1 class="text-4xl md:text-5xl lg:text-6xl font-bold uppercase tracking-wide mb-8 neon-glow text-center">
            Futuristic Snake
        </h1>

        <!-- Game Info Panel -->
        <div class="flex justify-between items-center w-full max-w-lg mb-4 p-4 rounded-xl bg-slate-800 border-2 border-cyan-400 container-glow">
            <span class="text-xl text-cyan-200 font-bold">Score: <span id="score" class="text-purple-400">0</span></span>
            <span class="text-xl text-cyan-200 font-bold">High Score: <span id="highScore" class="text-purple-400">0</span></span>
        </div>

        <!-- Game Canvas -->
        <canvas id="gameCanvas" width="400" height="400" class="max-w-full h-auto"></canvas>

        <!-- Control and Navigation -->
        <div class="mt-8 flex flex-col items-center space-y-4">
            <div class="text-white text-center">
                <p>Use the <span class="font-bold">WASD or Arrow Keys</span> to move.</p>
                <!-- Removed 'Press Enter or Return to restart' instruction from the UI -->
            </div>
            <!-- The Back to Main Menu button now links to index.html, as this file is intended to be the new index.html -->
            <a href="index.html" class="bg-purple-700 hover:bg-purple-600 text-white text-center font-bold py-3 px-6 rounded-full transition-colors btn-glow">
                BACK TO MAIN MENU
            </a>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div id="gameOverModal" class="hidden">
        <div id="gameOverContent">
            <div id="gameOverText" class="text-4xl md:text-5xl lg:text-6xl font-bold uppercase tracking-wide neon-glow text-center">
                Game Over!
            </div>
            <p id="finalScoreText" class="mt-4 text-xl text-white">Your Score: 0</p>
            <div class="flex flex-col space-y-4 mt-4">
                <button id="restartBtn" class="bg-purple-700 hover:bg-purple-600 text-white font-bold py-3 px-6 rounded-full transition-colors btn-glow">
                    RESTART
                </button>
                <a href="index.html" class="bg-purple-700 hover:bg-purple-600 text-white text-center font-bold py-3 px-6 rounded-full transition-colors btn-glow">
                    BACK TO MAIN MENU
                </a>
            </div>
        </div>
    </div>

    <script>
        window.onload = function() {
            // Get the game canvas and its context
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');

            // Define game variables
            const gridSize = 20;
            const tileCount = canvas.width / gridSize;
            let snake = [{ x: 10, y: 10 }];
            let food = {};
            let direction = 'right';
            let score = 0;
            let highScore = localStorage.getItem('highScore') || 0;
            let gameLoopInterval;
            let isGameOver = false;

            // Variables for the explosion effect
            let particles = [];
            const PARTICLE_COUNT = 100; // Increased particle count
            const PARTICLE_VELOCITY = 18; // Increased particle velocity

            // Variables for the score animation effect
            let scoreAnimations = [];

            // Get the score and high score elements
            const scoreElement = document.getElementById('score');
            const highScoreElement = document.getElementById('highScore');
            const gameOverModal = document.getElementById('gameOverModal');
            const finalScoreText = document.getElementById('finalScoreText');
            const restartBtn = document.getElementById('restartBtn');

            // Attach the click event listener to the restart button
            restartBtn.addEventListener('click', resetGame);

            // Update high score display
            highScoreElement.textContent = highScore;

            // Generate random food position
            function generateFood() {
                food = {
                    x: Math.floor(Math.random() * tileCount),
                    y: Math.floor(Math.random() * tileCount)
                };
                // Ensure food does not spawn on the snake
                for (let i = 0; i < snake.length; i++) {
                    if (food.x === snake[i].x && food.y === snake[i].y) {
                        generateFood();
                        break;
                    }
                }
            }

            // Draw everything on the canvas
            function draw() {
                // Clear the canvas
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw the grid lines
                ctx.strokeStyle = '#2d3748';
                for (let i = 0; i < tileCount; i++) {
                    for (let j = 0; j < tileCount; j++) {
                        ctx.strokeRect(i * gridSize, j * gridSize, gridSize, gridSize);
                    }
                }

                // Draw the snake
                ctx.fillStyle = '#ff007b';
                for (let i = 0; i < snake.length; i++) {
                    // Make the head a different color/shape for a cool effect
                    if (i === 0) {
                        ctx.fillStyle = '#0ff';
                    } else {
                        ctx.fillStyle = '#ff007b';
                    }
                    ctx.fillRect(snake[i].x * gridSize, snake[i].y * gridSize, gridSize, gridSize);
                    // Add a glowing effect
                    ctx.strokeStyle = '#0ff';
                    ctx.strokeRect(snake[i].x * gridSize, snake[i].y * gridSize, gridSize, gridSize);
                }

                // Draw the food
                ctx.fillStyle = '#a058d8'; // A vibrant purple color
                ctx.beginPath();
                ctx.arc(food.x * gridSize + gridSize / 2, food.y * gridSize + gridSize / 2, gridSize / 2, 0, 2 * Math.PI);
                ctx.fill();
                // Add a glowing effect
                ctx.strokeStyle = '#d89cff';
                ctx.stroke();

                // Draw and update explosion particles
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, 2 * Math.PI);
                    ctx.fillStyle = `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, ${p.opacity})`;
                    ctx.fill();

                    // Update particle properties for the next frame
                    p.x += p.vx;
                    p.y += p.vy;
                    p.size *= 0.85; // Faster size reduction
                    p.opacity -= 0.1; // Faster opacity decay

                    if (p.opacity <= 0 || p.size <= 0.5) {
                        particles.splice(i, 1); // Remove faded particles
                    }
                }

                // Draw and update score animations
                for (let i = scoreAnimations.length - 1; i >= 0; i--) {
                    const anim = scoreAnimations[i];
                    ctx.save();
                    ctx.translate(anim.x, anim.y);
                    ctx.font = `${anim.size}px 'Inter'`;
                    ctx.fillStyle = `rgba(255, 255, 255, ${anim.opacity})`;
                    ctx.textAlign = 'center';
                    ctx.fillText('+1', 0, 0);
                    ctx.restore();

                    // Update animation properties for the next frame
                    anim.y -= 1; // Float upwards
                    anim.opacity -= 0.02; // Fade out
                    anim.size += 0.5; // Grow slightly
                    if (anim.opacity <= 0) {
                        scoreAnimations.splice(i, 1);
                    }
                }
            }

            // The main game loop
            function gameLoop() {
                if (isGameOver) {
                    draw(); // Continue to draw particles even when the game is over
                    return;
                }

                // Move the snake
                const head = { x: snake[0].x, y: snake[0].y };
                switch (direction) {
                    case 'up':
                        head.y--;
                        break;
                    case 'down':
                        head.y++;
                        break;
                    case 'left':
                        head.x--;
                        break;
                    case 'right':
                        head.x++;
                        break;
                }
                snake.unshift(head);

                // Check for food consumption
                if (head.x === food.x && head.y === food.y) {
                    score++;
                    scoreElement.textContent = score;
                    if (score > highScore) {
                        highScore = score;
                        highScoreElement.textContent = highScore;
                        localStorage.setItem('highScore', highScore);
                    }
                    // Add a new score animation at the food's location
                    scoreAnimations.push({
                        x: food.x * gridSize + gridSize / 2,
                        y: food.y * gridSize + gridSize / 2,
                        size: 16,
                        opacity: 1
                    });
                    generateFood();
                } else {
                    // If no food is eaten, remove the tail
                    snake.pop();
                }

                // Check for collisions
                if (
                    head.x < 0 || head.x >= tileCount ||
                    head.y < 0 || head.y >= tileCount ||
                    checkCollisionWithSelf()
                ) {
                    endGame();
                }

                draw();
            }

            // Check if the snake has collided with itself
            function checkCollisionWithSelf() {
                for (let i = 1; i < snake.length; i++) {
                    if (snake[i].x === snake[0].x && snake[i].y === snake[0].y) {
                        return true;
                    }
                }
                return false;
            }

            // Handle keyboard input
            document.addEventListener('keydown', e => {
                const key = e.key.toLowerCase();
                switch (key) {
                    case 'w':
                    case 'arrowup':
                        if (direction !== 'down') direction = 'up';
                        break;
                    case 's':
                    case 'arrowdown':
                        if (direction !== 'up') direction = 'down';
                        break;
                    case 'a':
                    case 'arrowleft':
                        if (direction !== 'right') direction = 'left';
                        break;
                    case 'd':
                    case 'arrowright':
                        if (direction !== 'left') direction = 'right';
                        break;
                    /* Removed the 'Enter' and 'Return' key handlers */
                }
            });

            // Handle touch swipe for mobile
            let touchStartX = 0;
            let touchStartY = 0;

            canvas.addEventListener('touchstart', e => {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            });

            canvas.addEventListener('touchend', e => {
                const touchEndX = e.changedTouches[0].clientX;
                const touchEndY = e.changedTouches[0].clientY;
                const dx = touchEndX - touchStartX;
                const dy = touchEndY - touchStartY;

                if (Math.abs(dx) > Math.abs(dy)) {
                    // Horizontal swipe
                    if (dx > 0 && direction !== 'left') direction = 'right';
                    else if (direction !== 'right') direction = 'left';
                } else {
                    // Vertical swipe
                    if (dy > 0 && direction !== 'up') direction = 'down';
                    else if (direction !== 'down') direction = 'up';
                }
            });

            // Creates a burst of particles for the explosion effect
            function createExplosionParticles(x, y) {
                particles = []; // Clear any old particles
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    particles.push({
                        x: x + gridSize / 2,
                        y: y + gridSize / 2,
                        vx: (Math.random() - 0.5) * PARTICLE_VELOCITY, // Increased velocity for a faster burst
                        vy: (Math.random() - 0.5) * PARTICLE_VELOCITY, // Increased velocity for a faster burst
                        size: Math.random() * gridSize / 2,
                        opacity: 1,
                        color: {
                            r: Math.floor(Math.random() * 255),
                            g: Math.floor(Math.random() * 255),
                            b: Math.floor(Math.random() * 255)
                        }
                    });
                }
            }

            // Function to apply a screen shake effect
            function shakeScreen() {
                canvas.classList.add('shake');
                setTimeout(() => {
                    canvas.classList.remove('shake');
                }, 300); // Duration of the shake effect
            }

            // End game function
            function endGame() {
                isGameOver = true;
                // Trigger the screen shake and explosion at the point of collision
                createExplosionParticles(snake[0].x * gridSize, snake[0].y * gridSize);
                shakeScreen();

                // Use a Promise to ensure a delay before showing the modal
                new Promise(resolve => setTimeout(resolve, 1000)).then(() => {
                    clearInterval(gameLoopInterval);
                    finalScoreText.textContent = `Your Score: ${score}`;
                    gameOverModal.style.display = 'flex';
                });
            }

            // Restart game function
            function resetGame() {
                isGameOver = false;
                score = 0;
                scoreElement.textContent = score;
                snake = [{ x: 10, y: 10 }];
                direction = 'right';
                generateFood();
                gameOverModal.style.display = 'none';
                gameLoopInterval = setInterval(gameLoop, 150);
            }

            // Start the game for the first time
            generateFood();
            gameLoopInterval = setInterval(gameLoop, 150);
        };
    </script>
</body>
</html>
